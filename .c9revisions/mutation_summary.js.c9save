{"ts":1357759143748,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1357759163287,"patch":[[{"diffs":[[1,"// Copyright 2011 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n(function(global) {\n//  \"use strict\";\n\n  var matchesSelector = 'matchesSelector';\n  if ('webkitMatchesSelector' in Element.prototype)\n    matchesSelector = 'webkitMatchesSelector';\n  else if ('mozMatchesSelector' in Element.prototype)\n    matchesSelector = 'mozMatchesSelector';\n\n  var MutationObserver = global.MutationObserver || global.WebKitMutationObserver || global.MozMutationObserver;\n  if (MutationObserver === undefined) {\n    console.log('MutationSummary cannot load: DOM Mutation Observers are required.');\n    console.log('https://developer.mozilla.org/en-US/docs/DOM/MutationObserver');\n    return;\n  }\n\n  // NodeMap UtilityClass. Exposed as MutationSummary.NodeMap.\n  // TODO(rafaelw): Consider using Harmony Map when available.\n\n  var ID_PROP = '__mutation_summary_node_map_id__';\n  var nextId_ = 1;\n\n  function ensureId(node) {\n    if (!node[ID_PROP]) {\n      node[ID_PROP] = nextId_++;\n      return true;\n    }\n\n    return false;\n  }\n\n  function NodeMap() {\n    this.map_ = {};\n  };\n\n  NodeMap.prototype = {\n    set: function(node, value) {\n      ensureId(node);\n      this.map_[node[ID_PROP]] = {k: node, v: value};\n    },\n    get: function(node) {\n      if (ensureId(node))\n        return;\n      var byId = this.map_[node[ID_PROP]];\n      if (byId)\n        return byId.v;\n    },\n    has: function(node) {\n      return !ensureId(node) && node[ID_PROP] in this.map_;\n    },\n    'delete': function(node) {\n      if (ensureId(node))\n        return;\n      delete this.map_[node[ID_PROP]];\n    },\n    keys: function() {\n      var nodes = [];\n      for (var id in this.map_) {\n        nodes.push(this.map_[id].k);\n      }\n      return nodes;\n    }\n  };\n\n  function hasOwnProperty(obj, propName) {\n    return Object.prototype.hasOwnProperty.call(obj, propName);\n  }\n\n  // Reachability & Matchability changeType constants.\n  var STAYED_OUT = 0;\n  var ENTERED = 1;\n  var STAYED_IN = 2;\n  var EXITED = 3;\n\n  // Sub-states of STAYED_IN\n  var REPARENTED = 4;\n  var REORDERED = 5;\n\n  /**\n   * This is no longer in use, but conceptually it still represents the policy for\n   * reporting node movement:\n   *\n   *  var reachableMatchableProduct = [\n   *  //  STAYED_OUT,  ENTERED,     STAYED_IN,   EXITED\n   *    [ STAYED_OUT,  STAYED_OUT,  STAYED_OUT,  STAYED_OUT ], // STAYED_OUT\n   *    [ STAYED_OUT,  ENTERED,     ENTERED,     STAYED_OUT ], // ENTERED\n   *    [ STAYED_OUT,  ENTERED,     STAYED_IN,   EXITED     ], // STAYED_IN\n   *    [ STAYED_OUT,  STAYED_OUT,  EXITED,      EXITED     ]  // EXITED\n   *  ];\n   */\n\n  function enteredOrExited(changeType) {\n    return changeType == ENTERED || changeType == EXITED;\n  }\n\n  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);\n\n  function MutationProjection(rootNode, elementFilter, calcReordered, calcOldPreviousSibling) {\n    this.rootNode = rootNode;\n    this.elementFilter = elementFilter;\n    this.calcReordered = calcReordered;\n    this.calcOldPreviousSibling = calcOldPreviousSibling;\n  }\n\n  MutationProjection.prototype = {\n\n    getChange: function(node) {\n      var change = this.changeMap.get(node);\n      if (!change) {\n        change = {\n          target: node\n        };\n        this.changeMap.set(node, change);\n      }\n\n      if (node.nodeType == Node.ELEMENT_NODE)\n        change.matchCaseInsensitive = node instanceof HTMLElement && node.ownerDocument instanceof HTMLDocument;\n\n      return change;\n    },\n\n    getParentChange: function(node) {\n      var change = this.getChange(node);\n      if (!change.childList) {\n        change.childList = true;\n        change.oldParentNode = null;\n      }\n\n      return change;\n    },\n\n    handleChildList: function(mutation) {\n      this.childListChanges = true;\n\n      forEach(mutation.removedNodes, function(el) {\n        var change = this.getParentChange(el);\n\n        // Note: is it possible to receive a removal followed by a removal. This\n        // can occur if the removed node is added to an non-observed node, that\n        // node is added to the observed area, and then the node removed from\n        // it.\n        if (change.added || change.oldParentNode)\n          change.added = false;\n        else\n          change.oldParentNode = mutation.target;\n      }, this);\n\n      forEach(mutation.addedNodes, function(el) {\n        var change = this.getParentChange(el);\n        change.added = true;\n      }, this);\n    },\n\n    handleAttributes: function(mutation) {\n      this.attributesChanges = true;\n\n      var change = this.getChange(mutation.target);\n      if (!change.attributes) {\n        change.attributes = true;\n        change.attributeOldValues = {};\n      }\n\n      var oldValues = change.attributeOldValues;\n      if (!hasOwnProperty(oldValues, mutation.attributeName)) {\n        oldValues[mutation.attributeName] = mutation.oldValue;\n      }\n    },\n\n    handleCharacterData: function(mutation) {\n      this.characterDataChanges = true;\n\n      var change = this.getChange(mutation.target);\n      if (change.characterData)\n        return;\n      change.characterData = true;\n      change.characterDataOldValue = mutation.oldValue;\n    },\n\n    processMutations: function(mutations) {\n      this.mutations = mutations;\n      this.changeMap = new NodeMap;\n\n      this.mutations.forEach(function(mutation) {\n        switch (mutation.type) {\n          case 'childList':\n            this.handleChildList(mutation);\n            break;\n          case 'attributes':\n            this.handleAttributes(mutation);\n            break;\n          case 'characterData':\n            this.handleCharacterData(mutation);\n            break;\n        }\n      }, this);\n\n      // Calculate node movement.\n      var entered = this.entered = [];\n      var exited = this.exited = [];\n      var stayedIn = this.stayedIn = new NodeMap;\n\n      if (!this.childListChanges && !this.attributesChanges)\n        return; // No childList or attributes mutations occurred.\n\n      var matchabilityChange = this.matchabilityChange.bind(this);\n\n      var reachabilityChange = this.reachabilityChange.bind(this);\n      var wasReordered = this.wasReordered.bind(this);\n\n      var visited = new NodeMap;\n      var self = this;\n\n      function ensureHasOldPreviousSiblingIfNeeded(node) {\n        if (!self.calcOldPreviousSibling)\n          return;\n\n        self.processChildlistChanges();\n\n        var parentNode = node.parentNode;\n        var change = self.changeMap.get(node);\n        if (change && change.oldParentNode)\n          parentNode = change.oldParentNode;\n\n        change = self.childlistChanges.get(parentNode);\n        if (!change) {\n          change = {\n            oldPrevious: new NodeMap\n          };\n\n          self.childlistChanges.set(parentNode, change);\n        }\n\n        if (!change.oldPrevious.has(node)) {\n          change.oldPrevious.set(node, node.previousSibling);\n        }\n      }\n\n      function visitNode(node, parentReachable) {\n        if (visited.has(node))\n          return;\n        visited.set(node, true);\n\n        var change = self.changeMap.get(node);\n        var reachable = parentReachable;\n\n        // node inherits its parent's reachability change unless\n        // its parentNode was mutated.\n        if ((change && change.childList) || reachable == undefined)\n          reachable = reachabilityChange(node);\n\n        if (reachable == STAYED_OUT)\n          return;\n\n        // Cache match results for sub-patterns.\n        matchabilityChange(node);\n\n        if (reachable == ENTERED) {\n          entered.push(node);\n        } else if (reachable == EXITED) {\n          exited.push(node);\n          ensureHasOldPreviousSiblingIfNeeded(node);\n\n        } else if (reachable == STAYED_IN) {\n          var movement = STAYED_IN;\n\n          if (change && change.childList) {\n            if (change.oldParentNode !== node.parentNode) {\n              movement = REPARENTED;\n              ensureHasOldPreviousSiblingIfNeeded(node);\n            } else if (self.calcReordered && wasReordered(node)) {\n              movement = REORDERED;\n            }\n          }\n\n          stayedIn.set(node, movement);\n        }\n\n        if (reachable == STAYED_IN)\n          return;\n\n        // reachable == ENTERED || reachable == EXITED.\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          visitNode(child, reachable);\n        }\n      }\n\n      this.changeMap.keys().forEach(function(node) {\n        visitNode(node);\n      });\n    },\n\n    getChanged: function(summary) {\n      var matchabilityChange = this.matchabilityChange.bind(this);\n\n      this.entered.forEach(function(node) {\n        var matchable = matchabilityChange(node);\n        if (matchable == ENTERED || matchable == STAYED_IN)\n          summary.added.push(node);\n      });\n\n      this.stayedIn.keys().forEach(function(node) {\n        var matchable = matchabilityChange(node);\n\n        if (matchable == ENTERED) {\n          summary.added.push(node);\n        } else if (matchable == EXITED) {\n          summary.removed.push(node);\n        } else if (matchable == STAYED_IN && (summary.reparented || summary.reordered)) {\n          var movement = this.stayedIn.get(node);\n          if (summary.reparented && movement == REPARENTED)\n            summary.reparented.push(node);\n          else if (summary.reordered && movement == REORDERED)\n            summary.reordered.push(node);\n        }\n      }, this);\n\n      this.exited.forEach(function(node) {\n        var matchable = matchabilityChange(node);\n        if (matchable == EXITED || matchable == STAYED_IN)\n          summary.removed.push(node);\n      })\n    },\n\n    getOldParentNode: function(node) {\n      var change = this.changeMap.get(node);\n      if (change && change.childList)\n        return change.oldParentNode ? change.oldParentNode : null;\n\n      var reachabilityChange = this.reachabilityChange(node);\n      if (reachabilityChange == STAYED_OUT || reachabilityChange == ENTERED)\n        throw Error('getOldParentNode requested on invalid node.');\n\n      return node.parentNode;\n    },\n\n    getOldPreviousSibling: function(node) {\n      var parentNode = node.parentNode;\n      var change = this.changeMap.get(node);\n      if (change && change.oldParentNode)\n        parentNode = change.oldParentNode;\n\n      change = this.childlistChanges.get(parentNode);\n      if (!change)\n        throw Error('getOldPreviousSibling requested on invalid node.');\n\n      return change.oldPrevious.get(node);\n    },\n\n    getOldAttribute: function(element, attrName) {\n      var change = this.changeMap.get(element);\n      if (!change || !change.attributes)\n        throw Error('getOldAttribute requested on invalid node.');\n\n      if (change.matchCaseInsensitive)\n        attrName = attrName.toLowerCase();\n\n      if (!hasOwnProperty(change.attributeOldValues, attrName))\n        throw Error('getOldAttribute requested for unchanged attribute name.');\n\n      return change.attributeOldValues[attrName];\n    },\n\n    getAttributesChanged: function(postFilter) {\n      if (!this.attributesChanges)\n        return {}; // No attributes mutations occurred.\n\n      var attributeFilter;\n      var caseInsensitiveFilter;\n      if (postFilter) {\n        attributeFilter = {};\n        caseInsensitiveFilter = {};\n        postFilter.forEach(function(attrName) {\n          attributeFilter[attrName] = true;\n          var lowerAttrName = attrName.toLowerCase();\n          if (attrName != lowerAttrName) {\n            caseInsensitiveFilter[lowerAttrName] = attrName;\n          }\n        });\n      }\n\n      var result = {};\n\n      var nodes = this.changeMap.keys();\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n\n        var change = this.changeMap.get(node);\n        if (!change.attributes)\n          continue;\n\n        if (STAYED_IN != this.reachabilityChange(node) || STAYED_IN != this.matchabilityChange(node))\n          continue;\n\n        var element = node;\n        var oldValues = change.attributeOldValues;\n\n        Object.keys(oldValues).forEach(function(name) {\n          var localName = name;\n          if (change.matchCaseInsensitive && caseInsensitiveFilter && caseInsensitiveFilter[name])\n            localName = caseInsensitiveFilter[name];\n\n          if (attributeFilter && !attributeFilter[localName])\n            return;\n\n          if (element.getAttribute(name) == oldValues[name])\n            return;\n\n          if (!result[localName])\n            result[localName] = [];\n\n          result[localName].push(element);\n        });\n      }\n\n      return result;\n    },\n\n    getOldCharacterData: function(node) {\n      var change = this.changeMap.get(node);\n      if (!change || !change.characterData)\n        throw Error('getOldCharacterData requested on invalid node.');\n\n      return change.characterDataOldValue;\n    },\n\n    getCharacterDataChanged: function() {\n      if (!this.characterDataChanges)\n        return []; // No characterData mutations occurred.\n\n      var nodes = this.changeMap.keys();\n      var result = [];\n      for (var i = 0; i < nodes.length; i++) {\n        var target = nodes[i];\n        if (STAYED_IN != this.reachabilityChange(target) || STAYED_IN != this.matchabilityChange(target))\n          continue;\n\n        var change = this.changeMap.get(target);\n        if (!change.characterData ||\n            target.textContent == change.characterDataOldValue)\n          continue\n\n        result.push(target);\n      }\n\n      return result;\n    },\n\n    /**\n     * Returns whether a given node:\n     *\n     *    STAYED_OUT, ENTERED, STAYED_IN or EXITED\n     *\n     * the set of nodes reachable from the root.\n     *\n     * These four states are the permutations of whether the node\n     *\n     *   wasReachable(node)\n     *   isReachable(node)\n     *\n     */\n    reachabilityChange: function(node) {\n      this.reachableCache = this.reachableCache || new NodeMap;\n      this.wasReachableCache = this.wasReachableCache || new NodeMap;\n\n      // Close over owned values.\n      var rootNode = this.rootNode;\n      var changeMap = this.changeMap;\n      var reachableCache = this.reachableCache;\n      var wasReachableCache = this.wasReachableCache;\n\n      // An node's oldParent is\n      //   -its present parent, if nothing happened to it\n      //   -null if the first thing that happened to it was an add.\n      //   -the node it was removed from if the first thing that happened to it\n      //      was a remove.\n      function getOldParent(node) {\n        var change = changeMap.get(node);\n\n        if (change && change.childList) {\n          if (change.oldParentNode)\n            return change.oldParentNode;\n          if (change.added)\n            return null;\n        }\n\n        return node.parentNode;\n      }\n\n      // Is the given node reachable from the rootNode.\n      function getIsReachable(node) {\n        if (node === rootNode)\n          return true;\n        if (!node)\n          return false;\n\n        var isReachable = reachableCache.get(node);\n        if (isReachable === undefined) {\n          isReachable = getIsReachable(node.parentNode);\n          reachableCache.set(node, isReachable);\n        }\n        return isReachable;\n      }\n\n      // Was the given node reachable from the rootNode.\n      // A node wasReachable if its oldParent wasReachable.\n      function getWasReachable(node) {\n        if (node === rootNode)\n          return true;\n        if (!node)\n          return false;\n\n        var wasReachable = wasReachableCache.get(node);\n        if (wasReachable === undefined) {\n          wasReachable = getWasReachable(getOldParent(node));\n          wasReachableCache.set(node, wasReachable);\n        }\n        return wasReachable;\n      }\n\n      if (getIsReachable(node))\n        return getWasReachable(node) ? STAYED_IN : ENTERED;\n      else\n        return getWasReachable(node) ? EXITED : STAYED_OUT;\n    },\n\n    checkWasMatching: function(el, filter, isMatching) {\n      var change = this.changeMap.get(el);\n      if (!change || !change.attributeOldValues)\n        return isMatching;\n\n      var tagName = filter.tagName;\n      if (change.matchCaseInsensitive &&\n          tagName != '*' &&\n          hasOwnProperty(filter, 'caseInsensitiveTagName')) {\n        tagName = filter.caseInsensitiveTagName;\n      }\n\n      if (tagName != '*' && tagName != el.tagName)\n        return false;\n\n      var attributeOldValues = change.attributeOldValues;\n      var significantAttrChanged = filter.qualifiers.some(function(qualifier) {\n        if (qualifier.class)\n          return hasOwnProperty(attributeOldValues, 'class');\n        else if (qualifier.id)\n          return hasOwnProperty(attributeOldValues, 'id');\n        else {\n          return change.matchCaseInsensitive && hasOwnProperty(qualifier, 'caseInsensitiveAttrName') ?\n              hasOwnProperty(attributeOldValues, qualifier.caseInsensitiveAttrName) :\n              hasOwnProperty(attributeOldValues, qualifier.attrName)\n        }\n      });\n\n      if (!significantAttrChanged)\n        return isMatching;\n\n      for (var i = 0; i < filter.qualifiers.length; i++) {\n        var qualifier = filter.qualifiers[i];\n        var attrName;\n        if (qualifier.class)\n          attrName = 'class';\n        else if (qualifier.id)\n          attrName = 'id';\n        else {\n          if (change.matchCaseInsensitive &&\n              hasOwnProperty(qualifier, 'caseInsensitiveAttrName')) {\n            attrName = qualifier.caseInsensitiveAttrName;\n          } else {\n            attrName = qualifier.attrName;\n          }\n        }\n\n        var contains = qualifier.class ? true : qualifier.contains;\n\n        var attrOldValue = hasOwnProperty(attributeOldValues, attrName) ?\n            attributeOldValues[attrName] : el.getAttribute(attrName);\n\n        if (attrOldValue == null)\n          return false;\n\n        if (qualifier.hasOwnProperty('attrValue')) {\n          if (!contains && qualifier.attrValue !== attrOldValue)\n            return false;\n\n          var subvalueMatch = attrOldValue.split(' ').some(function(subValue) {\n            return subValue == qualifier.attrValue;\n          });\n\n          if (!subvalueMatch)\n            return false;\n        }\n      }\n\n      return true;\n    },\n\n    /**\n     * Returns whether a given element:\n     *\n     *   STAYED_OUT, ENTERED, EXITED or STAYED_IN\n     *\n     * the set of element which match at least one match pattern.\n     *\n     * These four states are the permutations of whether the element\n     *\n     *   wasMatching(node)\n     *   isMatching(node)\n     *\n     */\n    matchabilityChange: function(node) {\n      // TODO(rafaelw): Include PI, CDATA?\n      // Only include text nodes.\n      if (this.filterCharacterData) {\n        switch (node.nodeType) {\n          case Node.COMMENT_NODE:\n          case Node.TEXT_NODE:\n            return STAYED_IN;\n          default:\n            return STAYED_OUT;\n        }\n      }\n\n      // No element filter. Include all nodes.\n      if (!this.elementFilter)\n        return STAYED_IN;\n\n      // Element filter. Exclude non-elements.\n      if (node.nodeType !== Node.ELEMENT_NODE)\n        return STAYED_OUT;\n\n      var el = node;\n\n      function computeMatchabilityChange(filter) {\n        if (!this.matchCache)\n          this.matchCache = {};\n        if (!this.matchCache[filter.selectorString])\n          this.matchCache[filter.selectorString] = new NodeMap;\n\n        var cache = this.matchCache[filter.selectorString];\n        var result = cache.get(el);\n        if (result !== undefined)\n          return result;\n\n        var isMatching = el[matchesSelector](filter.selectorString);\n        var wasMatching = this.checkWasMatching(el, filter, isMatching);\n\n        if (isMatching)\n          result = wasMatching ? STAYED_IN : ENTERED;\n        else\n          result = wasMatching ? EXITED : STAYED_OUT;\n\n        cache.set(el, result);\n        return result;\n      }\n\n      var matchChanges = this.elementFilter.map(computeMatchabilityChange, this);\n      var accum = STAYED_OUT;\n      var i = 0;\n\n      while (accum != STAYED_IN && i < matchChanges.length) {\n        switch(matchChanges[i]) {\n          case STAYED_IN:\n            accum = STAYED_IN;\n            break;\n          case ENTERED:\n            if (accum == EXITED)\n              accum = STAYED_IN;\n            else\n              accum = ENTERED;\n            break;\n          case EXITED:\n            if (accum == ENTERED)\n              accum = STAYED_IN;\n            else\n              accum = EXITED;\n            break;\n        }\n\n        i++;\n      }\n\n      return accum;\n    },\n\n    processChildlistChanges: function() {\n      if (this.childlistChanges)\n        return;\n\n      var childlistChanges = this.childlistChanges = new NodeMap;\n\n      function getChildlistChange(el) {\n        var change = childlistChanges.get(el);\n        if (!change) {\n          change = {\n            added: new NodeMap,\n            removed: new NodeMap,\n            maybeMoved: new NodeMap,\n            oldPrevious: new NodeMap\n          };\n          childlistChanges.set(el, change);\n        }\n\n        return change;\n      }\n\n      var reachabilityChange = this.reachabilityChange.bind(this);\n      var self = this;\n\n      this.mutations.forEach(function(mutation) {\n        if (mutation.type != 'childList')\n          return;\n\n        if (reachabilityChange(mutation.target) != STAYED_IN && !self.calcOldPreviousSibling)\n          return;\n\n        var change = getChildlistChange(mutation.target);\n\n        var oldPrevious = mutation.previousSibling;\n\n        function recordOldPrevious(node, previous) {\n          if (!node ||\n              change.oldPrevious.has(node) ||\n              change.added.has(node) ||\n              change.maybeMoved.has(node))\n            return;\n\n          if (previous &&\n              (change.added.has(previous) ||\n               change.maybeMoved.has(previous)))\n            return;\n\n          change.oldPrevious.set(node, previous);\n        }\n\n        forEach(mutation.removedNodes, function(node) {\n          recordOldPrevious(node, oldPrevious);\n\n          if (change.added.has(node)) {\n            change.added.delete(node);\n          } else {\n            change.removed.set(node, true);\n            change.maybeMoved.delete(node, true);\n          }\n\n          oldPrevious = node;\n        });\n\n        recordOldPrevious(mutation.nextSibling, oldPrevious);\n\n        forEach(mutation.addedNodes, function(node) {\n          if (change.removed.has(node)) {\n            change.removed.delete(node);\n            change.maybeMoved.set(node, true);\n          } else {\n            change.added.set(node, true);\n          }\n        });\n      });\n    },\n\n    wasReordered: function(node) {\n      if (!this.childListChanges)\n        return false;\n\n      this.processChildlistChanges();\n\n      var parentNode = node.parentNode;\n      var change = this.changeMap.get(node);\n      if (change && change.oldParentNode)\n        parentNode = change.oldParentNode;\n\n      change = this.childlistChanges.get(parentNode);\n      if (!change)\n        return false;\n\n      if (change.moved)\n        return change.moved.get(node);\n\n      var moved = change.moved = new NodeMap;\n      var pendingMoveDecision = new NodeMap;\n\n      function isMoved(node) {\n        if (!node)\n          return false;\n        if (!change.maybeMoved.has(node))\n          return false;\n\n        var didMove = moved.get(node);\n        if (didMove !== undefined)\n          return didMove;\n\n        if (pendingMoveDecision.has(node)) {\n          didMove = true;\n        } else {\n          pendingMoveDecision.set(node, true);\n          didMove = getPrevious(node) !== getOldPrevious(node);\n        }\n\n        if (pendingMoveDecision.has(node)) {\n          pendingMoveDecision.delete(node);\n          moved.set(node, didMove);\n        } else {\n          didMove = moved.get(node);\n        }\n\n        return didMove;\n      }\n\n      var oldPreviousCache = new NodeMap;\n      function getOldPrevious(node) {\n        var oldPrevious = oldPreviousCache.get(node);\n        if (oldPrevious !== undefined)\n          return oldPrevious;\n\n        oldPrevious = change.oldPrevious.get(node);\n        while (oldPrevious &&\n               (change.removed.has(oldPrevious) || isMoved(oldPrevious))) {\n          oldPrevious = getOldPrevious(oldPrevious);\n        }\n\n        if (oldPrevious === undefined)\n          oldPrevious = node.previousSibling;\n        oldPreviousCache.set(node, oldPrevious);\n\n        return oldPrevious;\n      }\n\n      var previousCache = new NodeMap;\n      function getPrevious(node) {\n        if (previousCache.has(node))\n          return previousCache.get(node);\n\n        var previous = node.previousSibling;\n        while (previous && (change.added.has(previous) || isMoved(previous)))\n          previous = previous.previousSibling;\n\n        previousCache.set(node, previous);\n        return previous;\n      }\n\n      change.maybeMoved.keys().forEach(isMoved);\n      return change.moved.get(node);\n    }\n  }\n\n  // TODO(rafaelw): Allow ':' and '.' as valid name characters.\n  var validNameInitialChar = /[a-zA-Z_]+/;\n  var validNameNonInitialChar = /[a-zA-Z0-9_\\-]+/;\n\n  // TODO(rafaelw): Consider allowing backslash in the attrValue.\n  // TODO(rafaelw): There's got a to be way to represent this state machine\n  // more compactly???\n  function parseElementFilter(elementFilter) {\n    var selectorGroup = [];\n    var currentSelector;\n    var currentQualifier;\n\n    function newSelector() {\n      if (currentSelector) {\n        if (currentQualifier) {\n          currentSelector.qualifiers.push(currentQualifier);\n          currentQualifier = undefined;\n        }\n\n        selectorGroup.push(currentSelector);\n      }\n      currentSelector = {\n        qualifiers: []\n      }\n    }\n\n    function newQualifier() {\n      if (currentQualifier)\n        currentSelector.qualifiers.push(currentQualifier);\n\n      currentQualifier = {};\n    }\n\n\n    var WHITESPACE = /\\s/;\n    var valueQuoteChar;\n    var SYNTAX_ERROR = 'Invalid or unsupported selector syntax.';\n\n    var SELECTOR = 1;\n    var TAG_NAME = 2;\n    var QUALIFIER = 3;\n    var QUALIFIER_NAME_FIRST_CHAR = 4;\n    var QUALIFIER_NAME = 5;\n    var ATTR_NAME_FIRST_CHAR = 6;\n    var ATTR_NAME = 7;\n    var EQUIV_OR_ATTR_QUAL_END = 8;\n    var EQUAL = 9;\n    var ATTR_QUAL_END = 10;\n    var VALUE_FIRST_CHAR = 11;\n    var VALUE = 12;\n    var QUOTED_VALUE = 13;\n    var SELECTOR_SEPARATOR = 14;\n\n    var state = SELECTOR;\n    var i = 0;\n    while (i < elementFilter.length) {\n      var c = elementFilter[i++];\n\n      switch (state) {\n        case SELECTOR:\n          if (c.match(validNameInitialChar)) {\n            newSelector();\n            currentSelector.tagName = c;\n            state = TAG_NAME;\n            break;\n          }\n\n          if (c == '*') {\n            newSelector();\n            currentSelector.tagName = '*';\n            state = QUALIFIER;\n            break;\n          }\n\n          if (c == '.') {\n            newSelector();\n            newQualifier();\n            currentSelector.tagName = '*';\n            currentQualifier.class = true;\n            state = QUALIFIER_NAME_FIRST_CHAR;\n            break;\n          }\n          if (c == '#') {\n            newSelector();\n            newQualifier();\n            currentSelector.tagName = '*';\n            currentQualifier.id = true;\n            state = QUALIFIER_NAME_FIRST_CHAR;\n            break;\n          }\n          if (c == '[') {\n            newSelector();\n            newQualifier();\n            currentSelector.tagName = '*';\n            currentQualifier.attrName = '';\n            state = ATTR_NAME_FIRST_CHAR;\n            break;\n          }\n\n          if (c.match(WHITESPACE))\n            break;\n\n          throw Error(SYNTAX_ERROR);\n\n        case TAG_NAME:\n          if (c.match(validNameNonInitialChar)) {\n            currentSelector.tagName += c;\n            break;\n          }\n\n          if (c == '.') {\n            newQualifier();\n            currentQualifier.class = true;\n            state = QUALIFIER_NAME_FIRST_CHAR;\n            break;\n          }\n          if (c == '#') {\n            newQualifier();\n            currentQualifier.id = true;\n            state = QUALIFIER_NAME_FIRST_CHAR;\n            break;\n          }\n          if (c == '[') {\n            newQualifier();\n            currentQualifier.attrName = '';\n            state = ATTR_NAME_FIRST_CHAR;\n            break;\n          }\n\n          if (c.match(WHITESPACE)) {\n            state = SELECTOR_SEPARATOR;\n            break;\n          }\n\n          if (c == ',') {\n            state = SELECTOR;\n            break;\n          }\n\n          throw Error(SYNTAX_ERROR);\n\n        case QUALIFIER:\n          if (c == '.') {\n            newQualifier();\n            currentQualifier.class = true;\n            state = QUALIFIER_NAME_FIRST_CHAR;\n            break;\n          }\n          if (c == '#') {\n            newQualifier();\n            currentQualifier.id = true;\n            state = QUALIFIER_NAME_FIRST_CHAR;\n            break;\n          }\n          if (c == '[') {\n            newQualifier();\n            currentQualifier.attrName = '';\n            state = ATTR_NAME_FIRST_CHAR;\n            break;\n          }\n\n          if (c.match(WHITESPACE)) {\n            state = SELECTOR_SEPARATOR;\n            break;\n          }\n\n          if (c == ',') {\n            state = SELECTOR;\n            break;\n          }\n\n          throw Error(SYNTAX_ERROR);\n\n        case QUALIFIER_NAME_FIRST_CHAR:\n          if (c.match(validNameInitialChar)) {\n            currentQualifier.attrValue = c;\n            state = QUALIFIER_NAME;\n            break;\n          }\n\n          throw Error(SYNTAX_ERROR);\n\n        case QUALIFIER_NAME:\n          if (c.match(validNameNonInitialChar)) {\n            currentQualifier.attrValue += c;\n            break;\n          }\n\n          if (c == '.') {\n            newQualifier();\n            currentQualifier.class = true;\n            state = QUALIFIER_NAME_FIRST_CHAR;\n            break;\n          }\n          if (c == '#') {\n            newQualifier();\n            currentQualifier.id = true;\n            state = QUALIFIER_NAME_FIRST_CHAR;\n            break;\n          }\n          if (c == '[') {\n            newQualifier();\n            state = ATTR_NAME_FIRST_CHAR;\n            break;\n          }\n\n          if (c.match(WHITESPACE)) {\n            state = SELECTOR_SEPARATOR;\n            break;\n          }\n          if (c == ',') {\n            state = SELECTOR;\n            break\n          }\n\n          throw Error(SYNTAX_ERROR);\n\n        case ATTR_NAME_FIRST_CHAR:\n          if (c.match(validNameInitialChar)) {\n            currentQualifier.attrName = c;\n            state = ATTR_NAME;\n            break;\n          }\n\n          if (c.match(WHITESPACE))\n            break;\n\n          throw Error(SYNTAX_ERROR);\n\n        case ATTR_NAME:\n          if (c.match(validNameNonInitialChar)) {\n            currentQualifier.attrName += c;\n            break;\n          }\n\n          if (c.match(WHITESPACE)) {\n            state = EQUIV_OR_ATTR_QUAL_END;\n            break;\n          }\n\n          if (c == '~') {\n            currentQualifier.contains = true;\n            state = EQUAL;\n            break;\n          }\n\n          if (c == '=') {\n            currentQualifier.attrValue = '';\n            state = VALUE_FIRST_CHAR;\n            break;\n          }\n\n          if (c == ']') {\n            state = QUALIFIER;\n            break;\n          }\n\n          throw Error(SYNTAX_ERROR);\n\n        case EQUIV_OR_ATTR_QUAL_END:\n          if (c == '~') {\n            currentQualifier.contains = true;\n            state = EQUAL;\n            break;\n          }\n\n          if (c == '=') {\n            currentQualifier.attrValue = '';\n            state = VALUE_FIRST_CHAR;\n            break;\n          }\n\n          if (c == ']') {\n            state = QUALIFIER;\n            break;\n          }\n\n          if (c.match(WHITESPACE))\n            break;\n\n          throw Error(SYNTAX_ERROR);\n\n        case EQUAL:\n          if (c == '=') {\n            currentQualifier.attrValue = '';\n            state = VALUE_FIRST_CHAR\n            break;\n          }\n\n          throw Error(SYNTAX_ERROR);\n\n        case ATTR_QUAL_END:\n          if (c == ']') {\n            state = QUALIFIER;\n            break;\n          }\n\n          if (c.match(WHITESPACE))\n            break;\n\n          throw Error(SYNTAX_ERROR);\n\n        case VALUE_FIRST_CHAR:\n          if (c.match(WHITESPACE))\n            break;\n\n          if (c == '\"' || c == \"'\") {\n            valueQuoteChar = c;\n            state = QUOTED_VALUE;\n            break;\n          }\n\n          currentQualifier.attrValue += c;\n          state = VALUE;\n          break;\n\n        case VALUE:\n          if (c.match(WHITESPACE)) {\n            state = ATTR_QUAL_END;\n            break;\n          }\n          if (c == ']') {\n            state = QUALIFIER;\n            break;\n          }\n          if (c == \"'\" || c == '\"')\n            throw Error(SYNTAX_ERROR);\n\n          currentQualifier.attrValue += c;\n          break;\n\n        case QUOTED_VALUE:\n          if (c == valueQuoteChar) {\n            state = ATTR_QUAL_END;\n            break;\n          }\n\n          currentQualifier.attrValue += c;\n          break;\n\n        case SELECTOR_SEPARATOR:\n          if (c.match(WHITESPACE))\n            break;\n\n          if (c == ',') {\n            state = SELECTOR;\n            break\n          }\n\n          throw Error(SYNTAX_ERROR);\n      }\n    }\n\n    switch (state) {\n      case SELECTOR:\n      case TAG_NAME:\n      case QUALIFIER:\n      case QUALIFIER_NAME:\n      case SELECTOR_SEPARATOR:\n        // Valid end states.\n        newSelector();\n        break;\n      default:\n        throw Error(SYNTAX_ERROR);\n    }\n\n    if (!selectorGroup.length)\n      throw Error(SYNTAX_ERROR);\n\n    function escapeQuotes(value) {\n      return '\"' + value.replace(/\"/, '\\\\\\\"') + '\"';\n    }\n\n    selectorGroup.forEach(function(selector) {\n      var caseInsensitiveTagName = selector.tagName.toUpperCase();\n      if (selector.tagName != caseInsensitiveTagName)\n        selector.caseInsensitiveTagName = caseInsensitiveTagName;\n\n      var selectorString = selector.tagName;\n\n      selector.qualifiers.forEach(function(qualifier) {\n        if (qualifier.class)\n          selectorString += '.' + qualifier.attrValue;\n        else if (qualifier.id)\n          selectorString += '#' + qualifier.attrValue;\n        else {\n          var caseInsensitiveAttrName = qualifier.attrName.toLowerCase();\n          if (qualifier.attrName != caseInsensitiveAttrName)\n            qualifier.caseInsensitiveAttrName = caseInsensitiveAttrName;\n\n          if (qualifier.contains)\n            selectorString += '[' + qualifier.attrName + '~=' + escapeQuotes(qualifier.attrValue) + ']';\n          else {\n            selectorString += '[' + qualifier.attrName;\n            if (qualifier.hasOwnProperty('attrValue'))\n              selectorString += '=' + escapeQuotes(qualifier.attrValue);\n            selectorString += ']';\n          }\n        }\n      });\n\n      selector.selectorString = selectorString;\n    });\n\n    return selectorGroup;\n  }\n\n  var attributeFilterPattern = /^([a-zA-Z:_]+[a-zA-Z0-9_\\-:\\.]*)$/;\n\n  function validateAttribute(attribute) {\n    if (typeof attribute != 'string')\n      throw Error('Invalid request opion. attribute must be a non-zero length string.');\n\n    attribute = attribute.trim();\n\n    if (!attribute)\n      throw Error('Invalid request opion. attribute must be a non-zero length string.');\n\n\n    if (!attribute.match(attributeFilterPattern))\n      throw Error('Invalid request option. invalid attribute name: ' + attribute);\n\n    return attribute;\n  }\n\n  function validateElementAttributes(attribs) {\n    if (!attribs.trim().length)\n      throw Error('Invalid request option: elementAttributes must contain at least one attribute.');\n\n    var lowerAttributes = {};\n    var attributes = {};\n\n    var tokens = attribs.split(/\\s+/);\n    for (var i = 0; i < tokens.length; i++) {\n      var attribute = tokens[i];\n      if (!attribute)\n        continue;\n\n      var attribute = validateAttribute(attribute);\n      if (lowerAttributes.hasOwnProperty(attribute.toLowerCase()))\n        throw Error('Invalid request option: observing multiple case varitations of the same attribute is not supported.');\n      attributes[attribute] = true;\n      lowerAttributes[attribute.toLowerCase()] = true;\n    }\n\n    return Object.keys(attributes);\n  }\n\n  function validateOptions(options) {\n    var validOptions = {\n      'callback': true, // required\n      'queries': true,  // required\n      'rootNode': true,\n      'oldPreviousSibling': true,\n      'observeOwnChanges': true\n    };\n\n    var opts = {};\n\n    for (var opt in options) {\n      if (!(opt in validOptions))\n        throw Error('Invalid option: ' + opt);\n    }\n\n    if (typeof options.callback !== 'function')\n      throw Error('Invalid options: callback is required and must be a function');\n\n    opts.callback = options.callback;\n    opts.rootNode = options.rootNode || document;\n    opts.observeOwnChanges = options.observeOwnChanges;\n    opts.oldPreviousSibling = options.oldPreviousSibling;\n\n    if (!options.queries || !options.queries.length)\n      throw Error('Invalid options: queries must contain at least one query request object.');\n\n    opts.queries = [];\n\n    for (var i = 0; i < options.queries.length; i++) {\n      var request = options.queries[i];\n\n      // all\n      if (request.all) {\n        if (Object.keys(request).length > 1)\n          throw Error('Invalid request option. all has no options.');\n\n        opts.queries.push({all: true});\n        continue;\n      }\n\n      // attribute\n      if (request.hasOwnProperty('attribute')) {\n        var query = {\n          attribute: validateAttribute(request.attribute)\n        };\n\n        query.elementFilter = parseElementFilter('*[' + query.attribute + ']');\n\n        if (Object.keys(request).length > 1)\n          throw Error('Invalid request option. attribute has no options.');\n\n        opts.queries.push(query);\n        continue;\n      }\n\n      // element\n      if (request.hasOwnProperty('element')) {\n        var requestOptionCount = Object.keys(request).length;\n        var query = {\n          element: request.element,\n          elementFilter: parseElementFilter(request.element)\n        };\n\n        if (request.hasOwnProperty('elementAttributes')) {\n          query.elementAttributes = validateElementAttributes(request.elementAttributes);\n          requestOptionCount--;\n        }\n\n        if (requestOptionCount > 1)\n          throw Error('Invalid request option. element only allows elementAttributes option.');\n\n        opts.queries.push(query);\n        continue;\n      }\n\n      // characterData\n      if (request.characterData) {\n        if (Object.keys(request).length > 1)\n          throw Error('Invalid request option. characterData has no options.');\n\n        opts.queries.push({ characterData: true });\n        continue;\n      }\n\n      throw Error('Invalid request option. Unknown query request.');\n    }\n\n    return opts;\n  }\n\n  function elementFilterAttributes(filters) {\n    var attributes = {};\n\n    filters.forEach(function(filter) {\n      filter.qualifiers.forEach(function(qualifier) {\n        if (qualifier.class)\n          attributes['class'] = true;\n        else if (qualifier.id)\n          attributes['id'] = true;\n        else\n          attributes[qualifier.attrName] = true;\n      });\n    });\n\n    return Object.keys(attributes);\n  }\n\n  function createObserverOptions(queries) {\n    var observerOptions = {\n      childList: true,\n      subtree: true\n    };\n\n    var attributeFilter;\n    function observeAttributes(attributes) {\n      if (observerOptions.attributes && !attributeFilter)\n        return; // already observing all.\n\n      observerOptions.attributes = true;\n      observerOptions.attributeOldValue = true;\n\n      if (!attributes) {\n        // observe all.\n        attributeFilter = undefined;\n        return;\n      }\n\n      // add to observed.\n      attributeFilter = attributeFilter || {};\n      attributes.forEach(function(attribute) {\n        attributeFilter[attribute] = true;\n        attributeFilter[attribute.toLowerCase()] = true;\n      });\n    }\n\n    queries.forEach(function(request) {\n      if (request.characterData) {\n        observerOptions.characterData = true;\n        observerOptions.characterDataOldValue = true;\n        return;\n      }\n\n      if (request.all) {\n        observeAttributes();\n        observerOptions.characterData = true;\n        observerOptions.characterDataOldValue = true;\n        return;\n      }\n\n      if (request.attribute) {\n        observeAttributes([request.attribute.trim()]);\n        return;\n      }\n\n      if (request.elementFilter && request.elementFilter.some(function(f) { return f.className; } ))\n         observeAttributes(['class']);\n\n      var attributes = elementFilterAttributes(request.elementFilter).concat(request.elementAttributes || []);\n      if (attributes.length)\n        observeAttributes(attributes);\n    });\n\n    if (attributeFilter)\n      observerOptions.attributeFilter = Object.keys(attributeFilter);\n\n    return observerOptions;\n  }\n\n  function createSummary(projection, root, query) {\n    projection.elementFilter = query.elementFilter;\n    projection.filterCharacterData = query.characterData;\n\n    var summary = {\n      target: root,\n      type: 'summary',\n      added: [],\n      removed: []\n    };\n\n    summary.getOldParentNode = projection.getOldParentNode.bind(projection);\n\n    if (query.all || query.element)\n      summary.reparented = [];\n\n    if (query.all)\n      summary.reordered = [];\n\n    projection.getChanged(summary);\n\n    if (query.all || query.attribute || query.elementAttributes) {\n      var filter = query.attribute ? [ query.attribute ] : query.elementAttributes;\n      var attributeChanged = projection.getAttributesChanged(filter);\n\n      if (query.attribute) {\n        summary.valueChanged = [];\n        if (attributeChanged[query.attribute])\n          summary.valueChanged = attributeChanged[query.attribute];\n\n        summary.getOldAttribute = function(node) {\n          return projection.getOldAttribute(node, query.attribute);\n        }\n      } else {\n        summary.attributeChanged = attributeChanged;\n        if (query.elementAttributes) {\n          query.elementAttributes.forEach(function(attrName) {\n            if (!summary.attributeChanged.hasOwnProperty(attrName))\n              summary.attributeChanged[attrName] = [];\n          });\n        }\n        summary.getOldAttribute = projection.getOldAttribute.bind(projection);\n      }\n    }\n\n    if (query.all || query.characterData) {\n      var characterDataChanged = projection.getCharacterDataChanged()\n      summary.getOldCharacterData = projection.getOldCharacterData.bind(projection);\n\n      if (query.characterData)\n        summary.valueChanged = characterDataChanged;\n      else\n        summary.characterDataChanged = characterDataChanged;\n    }\n\n    if (summary.reordered)\n      summary.getOldPreviousSibling = projection.getOldPreviousSibling.bind(projection);\n\n    return summary;\n  }\n\n  function MutationSummary(opts) {\n    var connected = false;\n    var options = validateOptions(opts);\n    var observerOptions = createObserverOptions(options.queries);\n\n    var root = options.rootNode;\n    var callback = options.callback;\n\n    var elementFilter = Array.prototype.concat.apply([], options.queries.map(function(query) {\n      return query.elementFilter ? query.elementFilter : [];\n    }));\n    if (!elementFilter.length)\n      elementFilter = undefined;\n\n    var calcReordered = options.queries.some(function(query) {\n      return query.all;\n    });\n\n    var queryValidators = []\n    if (MutationSummary.createQueryValidator) {\n      queryValidators = options.queries.map(function(query) {\n        return MutationSummary.createQueryValidator(root, query);\n      });\n    }\n\n    function checkpointQueryValidators() {\n      queryValidators.forEach(function(validator) {\n        if (validator)\n          validator.recordPreviousState();\n      });\n    }\n\n    function runQueryValidators(summaries) {\n      queryValidators.forEach(function(validator, index) {\n        if (validator)\n          validator.validate(summaries[index]);\n      });\n    }\n\n    function createSummaries(mutations) {\n      if (!mutations || !mutations.length)\n        return [];\n\n      var projection = new MutationProjection(root, elementFilter, calcReordered, options.oldPreviousSibling);\n      projection.processMutations(mutations);\n\n      return options.queries.map(function(query) {\n        return createSummary(projection, root, query);\n      });\n    }\n\n    function changesToReport(summaries) {\n      return summaries.some(function(summary) {\n        var summaryProps =  ['added', 'removed', 'reordered', 'reparented',\n                             'valueChanged', 'characterDataChanged'];\n        if (summaryProps.some(function(prop) { return summary[prop] && summary[prop].length; }))\n          return true;\n\n        if (summary.attributeChanged) {\n          var attrsChanged = Object.keys(summary.attributeChanged).some(function(attrName) {\n            return summary.attributeChanged[attrName].length\n          });\n          if (attrsChanged)\n            return true;\n        }\n        return false;\n      });\n    }\n\n    var observer = new MutationObserver(function(mutations) {\n      if (!options.observeOwnChanges)\n        observer.disconnect();\n\n      var summaries = createSummaries(mutations);\n      runQueryValidators(summaries);\n\n      if (options.observeOwnChanges)\n        checkpointQueryValidators();\n\n      if (changesToReport(summaries))\n        callback(summaries);\n\n      if (!options.observeOwnChanges) {\n        checkpointQueryValidators();\n        observer.observe(root, observerOptions);\n      }\n    });\n\n    this.reconnect = function() {\n      if (connected)\n        throw Error('Already connected');\n\n      observer.observe(root, observerOptions);\n      connected = true;\n      checkpointQueryValidators();\n    };\n\n    var takeSummaries = this.takeSummaries = function() {\n      if (!connected)\n        throw Error('Not connected');\n\n      var mutations = observer.takeRecords();\n      var summaries = createSummaries(mutations);\n      if (changesToReport(summaries))\n        return summaries;\n    };\n\n    this.disconnect = function() {\n      var summaries = takeSummaries();\n\n      observer.disconnect();\n      connected = false;\n\n      return summaries;\n    };\n\n    this.reconnect();\n  }\n\n  // Externs\n  global.MutationSummary = MutationSummary;\n  global.MutationSummary.NodeMap = NodeMap; // exposed for use in TreeMirror.\n  global.MutationSummary.parseElementFilter = parseElementFilter; // exposed for testing.\n})(this);\n"]],"start1":0,"start2":0,"length1":0,"length2":47185}]],"length":47185,"saved":false}
